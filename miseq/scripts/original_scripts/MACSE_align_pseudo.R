#!/usr/bin/env Rscript

################################################################################

library(Biostrings)
# install.packages("remotes") 
# remotes::install_github("malnirav/hiReadsProcessor")
library(hiReadsProcessor)
library(dplyr)
library(seqinr)
library(argparse)

################################################################################

# Initialize command line argument parser for MACSE
parser <- ArgumentParser(description = 'Removing nuMTs using MACSE')
# All of your command line arguments
parser$add_argument('-d', '--directory', metavar = 'directory', type = 'character', required = TRUE, help = 'Specify MACSE directory on machine.')
# Parse the arguments
args <- parser$parse_args()
# Access the arguments
macse_jar <- args$directory

# create directories and name paths
path <- "miseq/COI/pseudo"
if(!dir.exists(path)) dir.create(path)

path_gc2 <- "miseq/COI/pseudo/gc2"
if(!dir.exists(path_gc2)) dir.create(path_gc2)

path_gc4 <- "miseq/COI/pseudo/gc4"
if(!dir.exists(path_gc4)) dir.create(path_gc4)

path_gc5 <- "miseq/COI/pseudo/gc5"
if(!dir.exists(path_gc5)) dir.create(path_gc5)

path_gc9 <- "miseq/COI/pseudo/gc9"
if(!dir.exists(path_gc9)) dir.create(path_gc9)

path_gc13 <- "miseq/COI/pseudo/gc13"
if(!dir.exists(path_gc13)) dir.create(path_gc13)

# path to files in the "data/macse_taxonomic_alignment" directory from GitHub
# generated by Daraghmeh (2024) (dx.doi.org/10.17504/protocols.io.n92ldmmmnl5b/v1)
macse_gc2 <- "metadata/macse_taxonomic_alignment/MACSE_BOLD_gc2_marine_taxa_aligned_NT.fasta"
macse_gc4 <- "metadata/macse_taxonomic_alignment/MACSE_BOLD_gc4_marine_taxa_aligned_NT.fasta"
macse_gc5 <- "metadata/macse_taxonomic_alignment/MACSE_BOLD_gc5_marine_taxa_aligned_NT.fasta"
macse_gc9 <- "metadata/macse_taxonomic_alignment/MACSE_BOLD_gc9_marine_taxa_aligned_NT.fasta"
macse_gc13 <- "metadata/macse_taxonomic_alignment/MACSE_BOLD_Tunicata_gc13_aligned_NT.fasta"

# path to COI_nochim_nosingle_ASVs.fa from COI_chimera
nochim_nosingle <- "miseq/COI/COI_nochim_nosingle_ASVs.fa"

# "the final, non-chimeric , non-singleton sequences with short >ASV... type headers"

fastafile <- read.fasta("miseq/COI/COI_nochim_nosingle_ASVs.fa",
                        seqtype = "DNA", as.string = TRUE)

################################################################################

### Run MACSE for genetic code 5 first 

path.cut <- file.path(path_gc5, "splitseqs")
if(!dir.exists(path.cut)) dir.create(path.cut)
x <- readDNAStringSet(nochim_nosingle)

# Split the fasta file into 20 fractions. 
# Make sure the input fasta is found in the respective directory

path_gc5_split <- file.path(path_gc5, "splitseqs")
splitSeqsToFiles(x, 20, "fasta", "splitseqs", path_gc5_split)

# Make list of the file names of these split sequences

split.files <- sort(list.files(path_gc5_split, pattern = ".fasta", full.names = TRUE))

# Create some output file names to use for MACSE

get.sample.name <- function(fname) strsplit(basename(fname), ".fasta")[[1]][1]
sample.names <- unname(sapply(split.files, get.sample.name))
sample.names
outputAA <- file.path(paste0(path_gc5_split, sample.names, "_AA_gc5.fa"))
outputNT <- file.path(paste0(path_gc5_split, sample.names, "_NT_gc5.fa"))
outputstats <- file.path(paste0(path_gc5_split, sample.names, "_stats_gc5.csv"))

# Run MACSE with enrichAlignment for genetic code 5
# Make sure the .jar file of MACSE and the respective reference alignment -NT.fasta are found in the repsective directories specified in the command
# Do not allow any in-frame stop codons, frameshifts or insertions and a maximum of 3 in-frame deletions (on amino acid level) in the enrichAlignment procedure.

for(i in seq_along(split.files)) {
  system2("java", 
  args = c("-jar", macse_jar, 
  "-prog", "enrichAlignment", "-align", macse_gc5, 
  "-seq ", split.files[i], 
  "-gc_def 5 -maxSTOP_inSeq 0 -output_only_added_seq_ON =TRUE -fixed_alignment_ON =TRUE -maxDEL_inSeq 3 -maxFS_inSeq 0 -maxINS_inSeq 0  -out_AA ", 
  outputAA[i], " -out_NT ", 
  outputNT[i], " -out_tested_seq_info ", 
  outputstats[i]))
}

# Make a table for pseudo and nonpseudo sequences.
# This is possible as running enrichAlignment will produce _stats.csv files for each alignment. These files show if an ASV has been added to the reference alignment under the specified settings regime. 

split.files.res <- sort(list.files(path_gc5, pattern = "_stats_gc5.csv", full.names = TRUE))
nonpseudo_gc5 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "yes")
  df <- data.frame(splitseqres1)
  nonpseudo_gc5 <- rbind(nonpseudo_gc5,df)
}
pseudo_gc5 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "no")
  df <- data.frame(splitseqres1)
  pseudo_gc5 <- rbind(pseudo_gc5,df)
}

# Subset those that were pseudogenes into a new fasta file

fastafile1 <- fastafile[c(which(names(fastafile) %in% pseudo_gc5$name))]
write.fasta(fastafile1, names=names(fastafile1), file.out = file.path(path_gc5_split, "gc5_pseudo.fasta"))

################################################################################

### Run MACSE for genetic code 4

# Read the previously created fasta file with the putative pseudogenes for genetic code 5 back into R and align these sequences with genetic code 4 to see if some of these may not be identified as pseudogenes with this translation table.

path.cut <- file.path(path_gc4, "splitseqs")
if(!dir.exists(path.cut)) dir.create(path.cut)
x <- readDNAStringSet(file = file.path(path_gc5_split, "gc5_pseudo.fasta"))

# Split this file into smaller fractions

path_gc4_split <- file.path(path_gc4, "splitseqs")
splitSeqsToFiles(x, 5, "split.fasta", "splitseqs", path_gc4_split)

split.files <- sort(list.files(path_gc4_split, pattern = ".fasta", full.names = TRUE))

# Create some output file names to use for MACSE

get.sample.name <- function(fname) strsplit(basename(fname), ".fasta")[[1]][1]
sample.names <- unname(sapply(split.files, get.sample.name))
sample.names
outputAA <- file.path(paste0(path_gc4_split, sample.names, "_AA_gc4.fa"))
outputNT <- file.path(paste0(path_gc4_split, sample.names, "_NT_gc4.fa"))
outputstats <- file.path(paste0(path_gc4_split, sample.names, "_stats_gc4.csv"))

# Run MACSE with enrichAlignment for genetic code 4
# Make sure the .jar file of MACSE and the respective reference alignment -NT.fasta are found in the repsective directories specified in the command
# Do not allow any in-frame stop codons, frameshifts or insertions and a maximum of 3 in-frame deletions (on amino acid level) in the enrichAlignment procedure.

for(i in seq_along(split.files)) {
  system2("java", 
  args = c("-jar", macse_jar, 
  "-prog", "enrichAlignment", "-align", macse_gc4, 
  "-seq", split.files[i], 
  "-gc_def 4 -maxSTOP_inSeq 0 -output_only_added_seq_ON =TRUE -fixed_alignment_ON =TRUE -maxDEL_inSeq 3 -maxFS_inSeq 0 -maxINS_inSeq 0  -out_AA ", 
  outputAA[i], " -out_NT ", 
  outputNT[i], " -out_tested_seq_info ", 
  outputstats[i]))
}

# Make a table for pseudo and nonpseudo sequences.
# This is possible as running enrichAlignment will produce _stats.csv files for each alignment. These files show if an ASV has been added to the reference alignment under the specified settings regime. 

split.files.res <- sort(list.files(path_gc4, pattern = "_stats_gc4.csv", full.names = TRUE))
nonpseudo_gc4 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "yes")
  df <- data.frame(splitseqres1)
  nonpseudo_gc4 <- rbind(nonpseudo_gc4,df)
}
pseudo_gc4 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "no")
  df <- data.frame(splitseqres1)
  pseudo_gc4 <- rbind(pseudo_gc4,df)
}

# Subset those that were pseudogenes into a new fasta file

fastafile1 <- fastafile[c(which(names(fastafile) %in% pseudo_gc4$name))]
write.fasta(fastafile1, names=names(fastafile1), file.out = file.path(path_gc4_split, "gc4_pseudo.fasta"))

################################################################################

### Run MACSE for genetic code 2

# Read the previously created fasta file with the putative pseudogenes for genetic code 4 back into R and align these sequences with genetic code 2 to see if some of these may not be identified as pseudogenes with this translation table.

path.cut <- file.path(path_gc2, "splitseqs")
if(!dir.exists(path.cut)) dir.create(path.cut)
x <- readDNAStringSet(file = file.path(path_gc4_split, "gc4_pseudo.fasta"))

# Split it into smaller fractions

path_gc2_split <- file.path(path_gc2, "splitseqs")
splitSeqsToFiles(x, 2, "split.fasta", "splitseqs", path_gc2_split)

split.files <- sort(list.files(path_gc2_split, pattern = ".fasta", full.names = TRUE))

# Create some output file names to use for MACSE

get.sample.name <- function(fname) strsplit(basename(fname), ".fasta")[[1]][1]
sample.names <- unname(sapply(split.files, get.sample.name))
sample.names
outputAA <- file.path(paste0(path_gc2_split, sample.names, "_AA_gc2.fa"))
outputNT <- file.path(paste0(path_gc2_split, sample.names, "_NT_gc2.fa"))
outputstats <- file.path(paste0(path_gc2_split, sample.names, "_stats_gc2.csv"))

# Run MACSE with enrichAlignment for genetic code 2
# Make sure the .jar file of MACSE and the respective reference alignment -NT.fasta are found in the repsective directories specified in the command
# Do not allow any in-frame stop codons, frameshifts or insertions and a maximum of 3 in-frame deletions (on amino acid level) in the enrichAlignment procedure.


for(i in seq_along(split.files)) {
  system2("java", 
  args = c("-jar", macse_jar, 
  "-prog", "enrichAlignment", "-align", macse_gc2, 
  "-seq ", split.files[i], "-gc_def 2 -maxSTOP_inSeq 0 -output_only_added_seq_ON =TRUE -fixed_alignment_ON =TRUE -maxDEL_inSeq 3 -maxFS_inSeq 0 -maxINS_inSeq 0  -out_AA ", 
  outputAA[i], " -out_NT ", 
  outputNT[i], " -out_tested_seq_info ", 
  outputstats[i]))
}

# Make a table for pseudo and nonpseudo sequences.
# This is possible as running enrichAlignment will produce _stats.csv files for each alignment. These files show if an ASV has been added to the reference alignment under the specified settings regime.

split.files.res <- sort(list.files(path_gc2, pattern = "_stats_gc2.csv", full.names = TRUE))
nonpseudo_gc2 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "yes")
  df <- data.frame(splitseqres1)
  nonpseudo_gc2 <- rbind(nonpseudo_gc2,df)
}
pseudo_gc2 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "no")
  df <- data.frame(splitseqres1)
  pseudo_gc2 <- rbind(pseudo_gc2,df)
}

# Subset those that were pseudogenes into a new fasta file

fastafile1 <- fastafile[c(which(names(fastafile) %in% pseudo_gc2$name))]
write.fasta(fastafile1, names=names(fastafile1), file.out = file.path(path_gc2_split, "gc2_pseudo.fasta"))

################################################################################

### Run MACSE for genetic code 9

# Read the previously created fasta file with the putative pseudogenes for genetic code 2 back into R and align these sequences with genetic code 9 to see if some of these may not be identified as pseudogenes with this translation table.

# Make list of the file names of these split sequences

path.cut <- file.path(path_gc9, "splitseqs")
if(!dir.exists(path.cut)) dir.create(path.cut)
x <- readDNAStringSet(file = file.path(path_gc2_split, "gc2_pseudo.fasta"))

# Split it into smaller fractions

path_gc9_split <- file.path(path_gc9, "splitseqs")
splitSeqsToFiles(x, 2, "split.fasta", "splitseqs", path_gc9_split)

split.files <- sort(list.files(path_gc9_split, pattern = ".fasta", full.names = TRUE))

# Create some output file names to use for MACSE

get.sample.name <- function(fname) strsplit(basename(fname), ".fasta")[[1]][1]
sample.names <- unname(sapply(split.files, get.sample.name))
sample.names
outputAA <- file.path(paste0(path_gc9_split, sample.names, "_AA_gc9.fa"))
outputNT <- file.path(paste0(path_gc9_split, sample.names, "_NT_gc9.fa"))
outputstats <- file.path(paste0(path_gc9_split, sample.names, "_stats_gc9.csv"))

# Run MACSE with enrichAlignment for genetic code 9
# Make sure the .jar file of MACSE and the respective reference alignment -NT.fasta are found in the repsective directories specified in the command
# Do not allow any in-frame stop codons, frameshifts or insertions and a maximum of 3 in-frame deletions (on amino acid level) in the enrichAlignment procedure.

for(i in seq_along(split.files)) {
  system2("java", 
  args = c("-jar", macse_jar, 
  "-prog", "enrichAlignment", "-align", macse_gc9, 
  "-seq", split.files[i], "-gc_def 9 -maxSTOP_inSeq 0 -output_only_added_seq_ON =TRUE -fixed_alignment_ON =TRUE -maxDEL_inSeq 3 -maxFS_inSeq 0 -maxINS_inSeq 0  -out_AA ", 
  outputAA[i], " -out_NT ", 
  outputNT[i], " -out_tested_seq_info ", 
  outputstats[i]))
}

# Make a table for pseudo and nonpseudo sequences.
# This is possible as running enrichAlignment will produce _stats.csv files for each alignment. These files show if an ASV has been added to the reference alignment under the specified settings regime.

split.files.res <- sort(list.files(path_gc9, pattern = "_stats_gc9.csv", full.names = TRUE))
nonpseudo_gc9 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "yes")
  df <- data.frame(splitseqres1)
  nonpseudo_gc9 <- rbind(nonpseudo_gc9,df)
}
pseudo_gc9 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "no")
  df <- data.frame(splitseqres1)
  pseudo_gc9 <- rbind(pseudo_gc9,df)
}

# Subset those that were pseudogenes into a new fasta file

fastafile1 <- fastafile[c(which(names(fastafile) %in% pseudo_gc9$name))]
write.fasta(fastafile1, names=names(fastafile1), file.out = file.path(path_gc9_split, "gc9_pseudo.fasta"))

################################################################################

### Run MACSE for genetic code 13

# Read the previously created fasta file with the putative pseudogenes for genetic code 9 back into R and align these sequences with genetic code 13 to see if some of these may not be identified as pseudogenes with this translation table.

path.cut <- file.path(path_gc13, "splitseqs")
if(!dir.exists(path.cut)) dir.create(path.cut)
x <- readDNAStringSet(file = file.path(path_gc9_split, "gc9_pseudo.fasta"))

# Split it into smaller fractions 

path_gc13_split <- file.path(path_gc13, "splitseqs")
splitSeqsToFiles(x, 2, "split.fasta", "splitseqs", path_gc13_split)

split.files <- sort(list.files(path_gc13_split, pattern = ".fasta", full.names = TRUE))

# Create some output file names to use for MACSE

get.sample.name <- function(fname) strsplit(basename(fname), ".fasta")[[1]][1]
sample.names <- unname(sapply(split.files, get.sample.name))
sample.names
outputAA <- file.path(paste0(path_gc13_split, sample.names, "_AA_gc13.fa"))
outputNT <- file.path(paste0(path_gc13_split, sample.names, "_NT_gc13.fa"))
outputstats <- file.path(paste0(path_gc13_split, sample.names, "_stats_gc13.csv"))

# Run MACSE with enrichAlignment for genetic code 13
# Make sure the .jar file of MACSE and the respective reference alignment -NT.fasta are found in the repsective directories specified in the command
# Do not allow any in-frame stop codons, frameshifts or insertions and a maximum of 3 in-frame deletions (on amino acid level) in the enrichAlignment procedure.

for(i in seq_along(split.files)) {
  system2("java", 
  args = c("-jar", macse_jar, 
  "-prog", "enrichAlignment", "-align", macse_gc13, 
  "-seq", split.files[i], "-gc_def 13 -maxSTOP_inSeq 0 -output_only_added_seq_ON =TRUE -fixed_alignment_ON =TRUE -maxDEL_inSeq 3 -maxFS_inSeq 0 -maxINS_inSeq 0  -out_AA ", 
  outputAA[i], " -out_NT ", 
  outputNT[i], " -out_tested_seq_info ", 
  outputstats[i]))
}

# Make a table for pseudo and nonpseudo sequences

split.files.res <- sort(list.files(path_gc13, pattern = "_stats_gc13.csv", full.names = TRUE))
nonpseudo_gc13 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "yes")
  df <- data.frame(splitseqres1)
  nonpseudo_gc13 <- rbind(nonpseudo_gc13,df)
}
pseudo_gc13 = data.frame()
for(i in seq_along(split.files.res)){
  splitseqres<-read.table(split.files.res[i], h=T, sep=";")
  splitseqres1 <- splitseqres %>%
    filter(added == "no")
  df <- data.frame(splitseqres1)
  pseudo_gc13 <- rbind(pseudo_gc13,df)
}

# Make a table for pseudo and nonpseudo sequences.
# This is possible as running enrichAlignment will produce _stats.csv files for each alignment. These files show if an ASV has been added to the reference alignment under the specified settings regime.

fastafile1 <- fastafile[c(which(names(fastafile) %in% pseudo_gc13$name))]
write.fasta(fastafile1, names=names(fastafile1), file.out = file.path(path_gc13_split, "gc13_pseudo.fasta"))

################################################################################

# Output those ASVs that are potential pseudos and the ones that are not

pseudo.combined <- rbind(pseudo_gc5, pseudo_gc4,pseudo_gc2,pseudo_gc9,pseudo_gc13)
pseudo.combined.names <- as.character(unique(pseudo.combined$name))
pseudo.combined.names<-paste0(">",pseudo.combined.names)
nonpseudo.combined <- rbind(nonpseudo_gc5, nonpseudo_gc4,nonpseudo_gc2,nonpseudo_gc9,nonpseudo_gc13)
nonpseudo.combined.names <- as.character(unique(nonpseudo.combined$name))
nonpseudo.combined.names<-paste0(">",nonpseudo.combined.names)

write.table(pseudo.combined.names, file = file.path(path, "pseudo.combined.names.txt"), row.names = F, col.names = F,quote = F)
write.table(nonpseudo.combined.names, file = file.path(path, "nonpseudo.combined.names.txt"), row.names = F, col.names = F,quote = F)
